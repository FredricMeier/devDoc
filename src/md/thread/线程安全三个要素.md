#线程安全的三个要素——原子性、可见性、有序性  
1. 原子性(Atomicity)  
由Java内存模型来直接保证的原子性变量操作包括read、load、use、assign、store和write六个，大致可以
认为基础数据类型的访问和读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java内存模
型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock与unlock操作直接开放给用户使用，但是
却提供了更高层次的字节码指令monitorenter和monitorexit来隐匿地使用这两个操作，这两个字节码指令反
映到Java代码中就是同步块---synchronized关键字，因此在synchronized块之间的操作也具备原子性。<br>
简单来说原子操作就是一个不可分割的操作，比如i=0（i非long或double类型），i++是一个非原子操作，可以
分为i = i + 1；非原子操作除了可以通过sychronized变成原子操作之外，还提供了更为灵活的API——Lock接
口来保证线程安全，另外在concurrent包下还提供了一些原子类，如：AtomicInteger、AtomicLong、
AtomicReference等。
2. 可见性(Visibility)  
可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。Java内存模型是通过在
变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实
现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile修饰的
变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，
volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个
操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就这这个操作同样存在线程安全问题。
除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized。同步块的可见性是由“对一个
变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)”这条规则获得的，而
final关键字的可见性是指：被final修饰的字段是构造器一旦初始化完成，并且构造器没有把“this”引用传
递出去，那么在其它线程中就能看见final字段的值。
3. 有序性(Ordering)  
Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个
线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排
序”现象和“工作内存主主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线
程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量
在同一时刻只允许一条线程对其进行lock操作”这条规则来获得的，这个规则决定了持有同一个锁的两个同步块
只能串行地进入。
<br>指令重排序的问题，编译器编译时会进行指令重排，代码执行顺序可能和编写顺序不一样：例如：
```java
int i = 0;
boolean flag = false; //语句3
i = 1;                //语句1  
flag = true;          //语句2`
```
语句1和语句2的执行顺序改变一下对程序的结果并没有什么影响，所以这时可能会改变这两条指令的顺
序。那么语句2会不会在语句3之前执行呢，答案是不会呢，因为语句2用到了语句3声明的变量，这时编
译器会限制语句的执行顺序来保证程序的正确性。
<br>在单线程中，改变指令的顺序可能不会产生不良后果，但是在多线程中就不一定了。例如：
```java
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2

//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
```
由于语句1和语句2没有数据依赖性，所以编译器可能会将两条指令重新排序，如果先执行语句2，这时线程
1被阻塞，然后线程2的while循环条件不满足，接着往下执行，但是由于context没有赋值，于是会产生错误。